## NOTE: This schema was generated by Graphback and should not be changed manually

"""Exposes a URL that specifies the behaviour of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behaviour of this scalar."""
  url: String!
) on SCALAR

""" @model """
type Band {
  _id: GraphbackObjectID!
  name: String!

  """
  @oneToMany(field: 'band', key: 'bandId')
  @oneToMany(field: 'band')
  """
  members(filter: MemberFilter): [Member!]!

  """
  @oneToMany(field: 'band', key: 'bandId')
  @oneToMany(field: 'band')
  """
  releases(filter: ReleaseFilter): [Release!]!
}

input BandFilter {
  _id: GraphbackObjectIDInput
  name: StringInput
  and: [BandFilter!]
  or: [BandFilter!]
  not: BandFilter
}

type BandResultList {
  items: [Band]!
  offset: Int
  limit: Int
  count: Int
}

input BandSubscriptionFilter {
  and: [BandSubscriptionFilter!]
  or: [BandSubscriptionFilter!]
  not: BandSubscriptionFilter
  _id: GraphbackObjectIDInput
  name: StringInput
}

input CreateBandInput {
  name: String!
}

input CreateMemberInput {
  name: String!
  instruments: [Instrument!]!
  bandId: GraphbackObjectID
}

input CreateReleaseInput {
  name: String!
  type: ReleaseType!
  year: Int!
  bandId: GraphbackObjectID
}

input CreateTrackInput {
  name: String!
  length: String!
  index: Int!
  releaseId: GraphbackObjectID
}

scalar GraphbackObjectID

input GraphbackObjectIDInput {
  ne: GraphbackObjectID
  eq: GraphbackObjectID
  le: GraphbackObjectID
  lt: GraphbackObjectID
  ge: GraphbackObjectID
  gt: GraphbackObjectID
  in: [GraphbackObjectID!]
  between: [GraphbackObjectID!]
}

enum Instrument {
  LEAD
  RHYTHM
  BASS
  KEYS
  VOCALS
  BACKING_VOCALS
  DRUMS
  PERCUSSION
  SAX
}

input IntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  in: [Int!]
  between: [Int!]
}

""" @model """
type Member {
  _id: GraphbackObjectID!
  name: String!
  instruments: [Instrument!]!

  """@manyToOne(field: 'members', key: 'bandId')"""
  band: Band
}

input MemberFilter {
  _id: GraphbackObjectIDInput
  name: StringInput
  instruments: StringInput
  bandId: GraphbackObjectIDInput
  and: [MemberFilter!]
  or: [MemberFilter!]
  not: MemberFilter
}

type MemberResultList {
  items: [Member]!
  offset: Int
  limit: Int
  count: Int
}

input MemberSubscriptionFilter {
  and: [MemberSubscriptionFilter!]
  or: [MemberSubscriptionFilter!]
  not: MemberSubscriptionFilter
  _id: GraphbackObjectIDInput
  name: StringInput
  instruments: StringInput
}

input MutateBandInput {
  _id: GraphbackObjectID!
  name: String
}

input MutateMemberInput {
  _id: GraphbackObjectID!
  name: String
  instruments: [Instrument]
  bandId: GraphbackObjectID
}

input MutateReleaseInput {
  _id: GraphbackObjectID!
  name: String
  type: ReleaseType
  year: Int
  bandId: GraphbackObjectID
}

input MutateTrackInput {
  _id: GraphbackObjectID!
  name: String
  length: String
  index: Int
  releaseId: GraphbackObjectID
}

type Mutation {
  createMember(input: CreateMemberInput!): Member
  updateMember(input: MutateMemberInput!): Member
  deleteMember(input: MutateMemberInput!): Member
  createBand(input: CreateBandInput!): Band
  updateBand(input: MutateBandInput!): Band
  deleteBand(input: MutateBandInput!): Band
  createRelease(input: CreateReleaseInput!): Release
  updateRelease(input: MutateReleaseInput!): Release
  deleteRelease(input: MutateReleaseInput!): Release
  createTrack(input: CreateTrackInput!): Track
  updateTrack(input: MutateTrackInput!): Track
  deleteTrack(input: MutateTrackInput!): Track
}

input OrderByInput {
  field: String!
  order: SortDirectionEnum = ASC
}

input PageRequest {
  limit: Int
  offset: Int
}

type Query {
  getMember(id: GraphbackObjectID!): Member
  findMembers(filter: MemberFilter, page: PageRequest, orderBy: OrderByInput): MemberResultList!
  getBand(id: GraphbackObjectID!): Band
  findBands(filter: BandFilter, page: PageRequest, orderBy: OrderByInput): BandResultList!
  getRelease(id: GraphbackObjectID!): Release
  findReleases(filter: ReleaseFilter, page: PageRequest, orderBy: OrderByInput): ReleaseResultList!
  getTrack(id: GraphbackObjectID!): Track
  findTracks(filter: TrackFilter, page: PageRequest, orderBy: OrderByInput): TrackResultList!
}

""" @model """
type Release {
  _id: GraphbackObjectID!
  name: String!
  type: ReleaseType!
  year: Int!

  """
  @oneToMany(field: 'release', key: 'releaseId')
  @oneToMany(field: 'release')
  """
  tracks(filter: TrackFilter): [Track!]!

  """@manyToOne(field: 'releases', key: 'bandId')"""
  band: Band
}

input ReleaseFilter {
  _id: GraphbackObjectIDInput
  name: StringInput
  type: StringInput
  year: IntInput
  bandId: GraphbackObjectIDInput
  and: [ReleaseFilter!]
  or: [ReleaseFilter!]
  not: ReleaseFilter
}

type ReleaseResultList {
  items: [Release]!
  offset: Int
  limit: Int
  count: Int
}

input ReleaseSubscriptionFilter {
  and: [ReleaseSubscriptionFilter!]
  or: [ReleaseSubscriptionFilter!]
  not: ReleaseSubscriptionFilter
  _id: GraphbackObjectIDInput
  name: StringInput
  type: StringInput
  year: IntInput
}

enum ReleaseType {
  SINGLE
  EP
  LP
}

enum SortDirectionEnum {
  DESC
  ASC
}

input StringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  in: [String!]
  contains: String
  startsWith: String
  endsWith: String
}

type Subscription {
  newMember(filter: MemberSubscriptionFilter): Member!
  updatedMember(filter: MemberSubscriptionFilter): Member!
  deletedMember(filter: MemberSubscriptionFilter): Member!
  newBand(filter: BandSubscriptionFilter): Band!
  updatedBand(filter: BandSubscriptionFilter): Band!
  deletedBand(filter: BandSubscriptionFilter): Band!
  newRelease(filter: ReleaseSubscriptionFilter): Release!
  updatedRelease(filter: ReleaseSubscriptionFilter): Release!
  deletedRelease(filter: ReleaseSubscriptionFilter): Release!
  newTrack(filter: TrackSubscriptionFilter): Track!
  updatedTrack(filter: TrackSubscriptionFilter): Track!
  deletedTrack(filter: TrackSubscriptionFilter): Track!
}

""" @model """
type Track {
  _id: GraphbackObjectID!
  name: String!
  length: String!
  index: Int!

  """@manyToOne(field: 'tracks', key: 'releaseId')"""
  release: Release
}

input TrackFilter {
  _id: GraphbackObjectIDInput
  name: StringInput
  length: StringInput
  index: IntInput
  releaseId: GraphbackObjectIDInput
  and: [TrackFilter!]
  or: [TrackFilter!]
  not: TrackFilter
}

type TrackResultList {
  items: [Track]!
  offset: Int
  limit: Int
  count: Int
}

input TrackSubscriptionFilter {
  and: [TrackSubscriptionFilter!]
  or: [TrackSubscriptionFilter!]
  not: TrackSubscriptionFilter
  _id: GraphbackObjectIDInput
  name: StringInput
  length: StringInput
  index: IntInput
}